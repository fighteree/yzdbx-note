
**学习目录：**

- [[#MYSQL慢查询]]
- [[#mysql索引]]
- [[#sql优化]]
- [[#un do log、 redo log 日志文件]]
- [[#MYSQL事务]]
- [[#MYSQL分库分表]]


## MYSQL慢查询

>[!note] 说明
>**mysql慢查询指sql语句执行耗时较长超过预期，一下的几种情况会导致慢sql的情况发生：**
>- sql中有大量聚合查询
>- sql连表过多
>- 单表数据量过大
>- 深度分页

### 如何定位慢查询？

1. **利用三方开源工具：**

    - 调试工具: `Arthas`
    - 运维工具: [Skywalking](https://skywalking.apache.org/)


2. **mysql自带慢日志文件:**

	在mysql的配置文件/etc/my.cnf中添加如下配置表示开启慢日志：
	![[Pasted image 20241116103415.png]]

```sql
-- 执行查询语句检查慢查询日志是否已经开启
SHOW VARIABLES LIKE 'slow_query_log';
-- 通过以下命令查看慢查询日志文件的路径
SHOW VARIABLES LIKE 'slow_query_log_file';`
```

>[!warning] 建议
>在生产环境下关闭慢日志来提高mysql执行性能。

--- 

## SQL执行分析

>[!tip] 提示
>mysql中可以使用`EXPLAINT`关键字来查看sql的执行情况从而帮助开发进行sql优化

**EXPLAINT回返的几种字段：**
- `type` : 表示这条sql使用了哪种[访问类型](MYSQL中EXPLAINT关键字访问类型)，反应了查询的性能。
- `possiblie_keys`: 表示<mark style="background: #FFB8EBA6;">可能</mark>会用到的索引。
- `keys`: 表示实际命中的索引。
- `key_len`: 索引的长度。
- `rows`: 扫描的行数，越小性能越好。
- `extra`: 表示额外的信息，例如是否使用了临时表、文件排序等。常见值包括Using index（表示查询使用了覆盖索引，只需要扫描索引就可以获得数据）、Using where（表示查询在服务器层进行了条件过滤）、Using temporary（表示查询使用了临时表）、Using filesort（表示查询使用了文件排序）等。

--- 

## mysql索引

>[!info] 概念
>mysql索引是一种能提高数据检测效率的数据结构。mysql在InnoDB引擎下使用B+树作为索引底层数据结构。


**索引的优点:**
  1. 提高数据检索效率。
  2. 索引生成是有序的，可以自动将索引列的数据进行排序从而降低了排序成本，降低了cpu的消耗。
  3. 降低了服务器对硬盘的IO次数。


**缺点：** 造成额外的硬盘资源消耗，空间换时间。并且在每次增删改的同时也要去维护索引树。

### B+树

>[!note] B+树
>B+树是一种多路平衡查找树，常用于实现关系型数据库中的索引。其底层原理和结构特点对于理解其高效性至关重要。

**B+树是B树的一种变体，每个节点可以有多个子节点，通常每个节点最多包含m个键（key）和m+1个指针（pointer），m称为节点的阶。**

- **节点结构**：
    
    - **非叶子节点**：仅存储键值和指向子节点的指针，不保存数据本身。其主要作用是提供一个索引路径，用于快速查找到叶子节点。
    - **叶子节点**：存储所有的数据项，并且按照键值大小有序排列。此外，叶子节点之间通过指针连接形成有序链表，便于范围查询。

>[!example] **三层B+树大概可装下2000w行数据**
>首先MYSQL的INODB引擎每个数据页的大小默认为16KB，对应着B+树的每个节点的大小，一般来说指针的大小为8个字节，加上索引key6字节，共14字节，那么每页（节点）就可以存放16KB / 14B ≈ 1170个指针。我们在假设一行数据的大小为1KB，那么一页就可以存放16KB / 1KB = 16 行数据。三层B+树就一共能存放1170 × 1170 × 16 = 21902400行数据，也就是说查询2000万条数据的表理论上只需要进行2次IO就可以，因为根节点的1170个指针会被MYSQL缓存到内存中。所以说B+树大大的降低了服务器对硬盘的IO次数提升了查询的性能。

---

### 索引创建原则

- **索引有哪些?**
	1. 主键索引
	2. 普通索引
	3. 唯一索引
	4. 复合索引（结合业务创建）
	5. 全文索引（用的不多）

- **索引创建原则有哪些？**
	1. 针对单表数据量较大一般前期预估数据量超过10w+且查询较为频繁的表可以添加索引来增加用户的体验度。
	2. 针对常用与`where、order by、group by` 列的字段可以添加索引。
	3. 尽量选择区分度较高的列来进行索引创建，如果是一些状态标识的字段不建议创建索引。
	4. 字符串过长的字段可以添加前缀索引只需要截取指定的前几个字符来创建索引。
	5. 尽量根据业务去创建复合索引，减少创建单列索引，可以避免回表的操作，直接使用覆盖索引来提升查询的效率。
	6. 要控制创建索引的数量，如果是增删改较多，需要同时去维护索引的结构，得不偿失。


### 索引失效的情况

- 创建复合索引的情况下编写sql语句时必须按照最`左匹配原则`。
- 范围查询的右边索引可能会失效。
- 在索引列进行运算会导致索引失效。
- 字符串不加单引号也会导致索引失效。
- 模糊查询%在前面会导致索引失效，因为b+树是通过计算第一个字符的`ASCII码` 来进行排序的。

--- 

## sql优化

**SQL优化有一下几种：**

- 表设计优化 
	1. 选择适合的数据类型可以减小硬盘的储存开销
	2. 热冷字段分离，常用于展示在前端的字段和点击详情才能看到的字段其实可以分成两张表，减少单表的字段数量
	3. 避免使用NULL尽量避免在表中使用NULL值。NULL值会增加存储开销，并可能导致查询性能下降。如果某个字段不是必需的，可以考虑使用默认值或空字符串来代替。
	4. 对于经常需要归档或删除的旧数据，考虑实施数据生命周期管理策略。这可以确保数据库保持精简和高效。
	5. 规范化和反规范化：
	    规范化：通过减少数据冗余来提高数据一致性。通常，将表拆分成多个更小的、关系更明确的表，并通过外键建立关系。
	    反规范化：在某些情况下，为了提高查询性能，可能会故意增加数据冗余，减少表连接的需求。但这需要在数据一致性和查询性能之间做出权衡。

- 索引优化<mark style="background: #FFB8EBA6;">（参考上面索引创建原则、失效情况）</mark>

- sql语句优化
	1. 尽量减少连表查询
	2. 将一些对字段的函数计算放到业务层去做
	3. 小表驱动大表

- [主从复制、读写分离](MYSQL主从复制、读写分离)

- 分库分表

--- 

## MYSQL事物

### 事物的特性

- **原子性：** 字面意思，指事物包含的一些操作是一个整体，要么同时成功要么同时失败。
- **一致性：** 事物的前后数据应该是一致的。`比如说A和B两个账户都有1000，合计就是2000，那么它们之间不管怎么转账合计都只能是2000`
- **隔离性：** 事物一旦开始就不能受外界并发操作的影响。
- **持久性：** 事物提交或是回滚后数据要进行落盘，且不能修改。


### 并发事物带来的问题，怎么解决？

- **脏读：** 一个事物中可以读到另一个事物未提交的数据。

- **不可重复读：** 一个事物中根据同一个ID查询两次数据不一致。

- **幻读：** 一个事务中首先根据ID查询结果为空，当以为没有这个ID的数据准备要插入时却报错了，原因是另一个事物已经抢先一步插入了这条数据并且已经提交了。

>[!note] 怎么解决以上的事物问题？
>mysql内置了四种不同的隔离级别，分别的解决了以上的部分问题。安全性从高到底为如下：
>- 读未提交 READ UNCOMMITTED `啥也不能解决，安全性最低`
>- 读已提交 READ COMMITTED       `只能解决脏读，幻读和不可重复读无法解决`
>- 可重复读 REPEABLE READ           `除了幻读都能解决`
>- 串行化 SERIALIZABLE                   `都能解决`

<mark style="background: #FFB8EBA6;">MYSQL的默认隔离级别为可重复读。</mark>
 
--- 

## un do log、 redo log 日志文件

### redo log日志文件
>[!note] 作用
>用于mysql在事务提交后进行数据持久化时发生错误的恢复手段。事物提交后会将对`数据页`的修改记录首先缓存到`redo log buffer` 中然后在以追加的方式写入到硬盘中的`redo log日志文件` 中，在mysql恢复后可以读取重写日志中的记录进行恢复。

- **redo log buffer:** mysql在内存中用于记录更新记录的缓冲池。
- **redo log file:** mysql在硬盘中记录更新记录的文件。



### undo 日志文件
>[!note] 作用
>记录数据变更前的版本，用于进行回滚操作。同时配合`MVCC多版本并发控制`来对并发事物进行事物隔离的作用。

#### 什么是MVCC多版本并发控制？

主要解决问题： 在多个并发事物中对数据进行隔离的一种规则。它的底层分为几个部分。

1. `undo log日志文件`: 主要记录了数据在多个事务中发生了变化的版本数据，每个版本之间由`回滚指针`进行串联，形成了一个链表结构。

2. `隐藏字段`：
	- tx_id :每个数据版本的ID，当数据被事物修改后这个ID会自增且这行数据会保存在`undo log日志文件中` 。
	- roll_ptr: 每行数据都有一个指向上个版本的指针，称为回滚指针。

3.  `readviwe读视图`：在InnoDB引擎中读视图是一个包含了多个字段的`结构体`，并制定了一些规则来进行判断数据的是否可见。
	- creator_trx_id：创建读视图的事物ID。
	- min_trx_id: 在**活跃事物**<mark style="background: #FFB8EBA6;">(指还没有提交的事务)</mark>中最小的事物ID。
	- max_trx_id: 在活跃事物中最大的事务ID。
	- trx_ids: 活跃事务ID的集合。

4.  规则：
	1. trx_id == 创建者事务ID **可见**
	2. trx_id < min_trx_id **可见**
	3. ...........

**规则总结：** <mark style="background: #FFB8EBA6;">只可以回返已经提交事务的数据，没有提交事务的数据是被规则隔离开的。在RC（读已提交）模式下每次select查询都会创建一个新的`readview` 。在RR（可重复读）模式下只会创建一次`readview`后续的selelct都是复用这一个读视图。</mark>


## MYSQL分库分表

- **垂直分库：** 将表按照业务去拆分为多个库来存储，典型的微服务架构。能够提升并发的网络IO和磁盘IO性能。
- **垂直分表：** 冷热数据分离，一般将一些需要点击详情才需要查询的数据放到一张附属表，然后一对一进行关联，能提高SQL的执行效率。
- **水平分库：** 将一个库的数据分成多个库进行储存，可以解决单库数据量较大的问题，然后使用路由规则进行数据操作。
- **水平分表：** 将一张表的数据分成多张表来储存，可以解决单表数据量较大，提升查询性能。

```
有关数据库分库分表的中间件: MYCAT、ShardingSphere
```


